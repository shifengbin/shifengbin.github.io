<!doctype html><html lang=zh dir=auto><head><meta name=generator content="Hugo 0.144.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blog Zone</title>
<meta name=keywords content="Blog,dev,git,k8s,network,go"><meta name=description content="日常记录,学习笔记"><meta name=author content="Fengbin"><link rel=canonical href=https://shifengbin.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><link rel=icon href=https://shifengbin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shifengbin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shifengbin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://shifengbin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://shifengbin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://shifengbin.github.io/index.xml><link rel=alternate hreflang=zh href=https://shifengbin.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Blog Zone","url":"https://shifengbin.github.io/","description":"日常记录,学习笔记","thumbnailUrl":"https://shifengbin.github.io/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shifengbin.github.io/ accesskey=h title="Blog Zone (Alt + H)">Blog Zone</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://shifengbin.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://shifengbin.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://shifengbin.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><div class=post-content><p><img loading=lazy src=/images/201220120347-5.jpg alt=head>
Welcome to my blog.</p></div><article class=post-entry><header class=entry-header><h2>树莓派系统关闭swap</h2></header><div class=entry-content><p>网上很多教程通过编辑/etc/fstab编辑swap, 但是在树莓派系统中,并不使用fstab配置,正确的做法是
编辑/etc/dphys-swapfile 找到配置项CONF_SWAPSIZE (通过名称我们可以知道该配置项为swap大小)该值配置为0 使配置生效 sudo /etc/init.d/dphys-swapfile restart 或者 sudo reboot 重启 通过free -h命令查看swap大小</p></div><footer class=entry-footer>2022-10-02 21:10:36&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;15 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 树莓派系统关闭swap" href=https://shifengbin.github.io/posts/pi/swap/></a></article><article class=post-entry><header class=entry-header><h2>Qemu+gdb裸机调试</h2></header><div class=entry-content><p>假设我们有一个boot.bin裸机汇编程序 我们想用qemu进行调试
我们可以使用qemu-system-x86_64 -s -S boot.bin
参数说明:
-s 可以使qemu开启1234端口,方便我们使用gdb连接调试
-S 可以让qemu暂停执行,等待我们使用gdb发送调试命令
gdb 连接:
使用gdb命令,进入gdb后使用target remote 127.0.0.1:1234连接到qemu</p></div><footer class=entry-footer>2022-09-23 16:31:24&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;16 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Qemu+gdb裸机调试" href=https://shifengbin.github.io/posts/os/qemu_gdb/></a></article><article class=post-entry><header class=entry-header><h2>errgroup</h2></header><div class=entry-content><p>errgroup是一个很简单的工具包,总共代码量加上注释和空行才100来行
作用就是方便执行的任务,比如
g := errgroup.Group{} g.Go(func1) g.Go(func2) if err := g.Wait(); err != nil { //... } 结构
type Group struct { cancel func() //context 取消函数 wg sync.WaitGroup //用来等待全部执行完成 sem chan token //用来控制并发数 errOnce sync.Once //控制err字段只赋值一次 err error //错误 } 主要函数
func (g *Group) Go(f func() error) { if g.sem != nil { g.sem &lt;- token{} //限制并发数, 并发数由管道能容纳下的token个数决定 } g.wg.Add(1) go func() { defer g.done() if err := f(); err != nil { g.errOnce.Do(func() { //如果出错后只赋值一次err g.err = err if g.cancel != nil { //如果使用的是WithContext,这个字段会有值, 调用取消函数 g.cancel() } }) } }() } 主要的东西就这么点, 可以看到errgroup还是一个很简洁的小工具, 配合singleflight一起使用挺不错</p></div><footer class=entry-footer>2022-09-06 17:22:20&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;95 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to errgroup" href=https://shifengbin.github.io/posts/go_source/errgroup/></a></article><article class=post-entry><header class=entry-header><h2>AMQP 0-9-1协议</h2></header><div class=entry-content><p>约定 下面出现的无特殊说明都是按下面对应关系
Publishers(发布者/生产者)
Consumers(消费者)
Exchanges(交换机)
Broker(中间件)
Queues(队列)
Bingdings(绑定)
AMQP是什么 AMQP是Advanced Message Queuing Protocol的缩写,高级消息队列协议,是一种消息传递协议
中间件和角色 消息中间件从Publishers(发布者/生产者)接收消息,路由到Consumers(消费者)
因为AMQP是网络协议, 发布者,消费者,中间件能够在不同的机器上.
AMQP模型简介 AMQP模型有下面的视角:
消息被发布到交换机(exchange,通常被比作邮局或邮箱) 交换机(exchanges)根据绑定(bindings)规则把消息复制到队列(queues) 中间件(borker)把消息投递到订阅队列或者从队列中拉取的消费者(consumers) 当一个消息发布时, 生产者可以设置一些消息属性(消息元数据meta data).一些元数据被中间件使用,剩下其他的被不透明发送到中间件给应用程序使用.
网络是不可靠的,应用也有可能处理消息失败,AMQP 0-9-1有一个消息应答(acknowledgements)的概念:当一个消息派发给消费者,消费者会通知中间件,可以自动执行或者开发者选择执行.当使用消息确认时,收到消息的通知就会从队列里删除该消息.
在某些情况,比如一个消息无法被路由,消息将会返回给生产者,丢弃,或者如果中间件实现一个扩展放入死信队列.生产者通过发布消息携带某些参数来处理这些情况.
队列(queue)、交换机(exchanges)和绑定(bingdings)统称为AMQP实体.
AMQP是一个可编程的协议 AMQP是一种可编程协议，AMQP的实体和路由方案主要由应用程序自己定义，而不是由中间件管理员定义.因此，为声明队列和交换机、定义它们之间的绑定、订阅队列等操作做出了规定.
这给应用程序开发者很大的自由,但是这也要求他们意识到潜在的定义冲突,在实践中定义冲突很少，通常是配置错误。
应用定义他们需要的实体,定义必要的路由规则和不在使用时删除实体
交换机和交换机类型 交换机是向其发送消息的AMQP实体,交换机接收消息并将其路由到零个或多个队列中。使用的路由算法取决于交换机类型和绑定,AMQP协议提供四种交换机类型:
交换机类型 默认名称 Direct exchange(直接交换机) (Empty string) and amq.direct Fanout exchange(扇出交换机) amq.fanout Topic exchange(主题交换机) amq.topic Headers exchange(头交换机) amq.match (and amq.headers in RabbitMQ) 除了交换机类型之外，交换机还使用许多属性来声明，其中最重要的是:
Name (名称) Durability (中间件重启后持久化) Auto-delete (最后一个队列解除绑定自动删除) Arguments (参数,可选的, 由插件和中间件特定功能使用) 交换机可以是持久的或者是临时的,持久性交换机在中间件重启后仍能存在，而暂时性交换机则不能.并非所有场景和用例都要求交换机持久化.
默认交换机 默认交换机是一个没有名称预定义在broker的直接交换机(direct exchange),它有一个特殊的特性，这使得它对于简单的应用程序非常有用:每个被创建的队列都会用和队列名称相同的路由键(routing key)自动绑定默认交换机.
...</p></div><footer class=entry-footer>2022-08-02 11:06:49&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;98 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to AMQP 0-9-1协议" href=https://shifengbin.github.io/posts/net/amqp/></a></article><article class=post-entry><header class=entry-header><h2>Fisher-Yates Shuffle</h2></header><div class=entry-content><p>这个算法发是今天看了一个go的代码库看到的,通过lo库看到有个Shuffle函数点进去看了一下,调用的数标准库中的shuffle算法,看了一下介绍,感觉有点意思,记录一下
Fisher-Yates算法是什么 Fisher-Yates算法 是一种生成随机排列的算法
核心原理 — To shuffle an array ‘a’ of ‘n’ elements: //对于一个规模为n的集合 for i from n-1 down to 1 do //从后向前遍历 j = random integer such that 0 &lt;= j &lt;= i //随机一个从0-i数字 exchange a[j] and a[i] //交换随机下标和当前下标的元素交换 用语言描述就是:
从后向前遍历 随机一个下标范围是0到当前下标,(范围包含当前下标是因为可能不交换) 交换随机下标指向的值和当前下标指向的值 go语言描述 func init(){ rand.Seed(time.Now().Unix()) } func Shuffle[T any](t []T) { for i := len(t) - 1; i > 0; i-- { j := rand.Int() % (i + 1) t[i], t[j] = t[j], t[i] } }</p></div><footer class=entry-footer>2022-07-27 11:41:33&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;80 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Fisher-Yates Shuffle" href=https://shifengbin.github.io/posts/algorithm/shuffle/></a></article><article class=post-entry><header class=entry-header><h2>语法图</h2></header><div class=entry-content><p>语法图又称铁路图，是EBNF(扩展巴克斯范式)的图形化表示
从左边界开始沿着轨道去到右边界。 沿途，你将在圆框中遇到的是字面量，在方块中遇到的是规则或者描述。 任何沿着轨道能走通的序列都是合法的。 任何不能沿着轨道走通的序列都是非法的。 /* a simple program in EBNF − Wikipedia */ program ::= 'PROGRAM' whiteSpace identifier whiteSpace 'BEGIN' whiteSpace (assignment ";")* 'END.' assignment ::= identifier ":=" ( number | identifier | string ) string ::= '"' [A-Z0-9_]+ '"' identifier ::= [A-Z] [0-9A-Z]* whiteSpace ::= [#x20]</p></div><footer class=entry-footer>2022-07-07 18:00:27&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;48 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 语法图" href=https://shifengbin.github.io/posts/compiler/syntax_graph/></a></article><article class=post-entry><header class=entry-header><h2>EBNF</h2></header><div class=entry-content><p>EBNF 扩展巴科斯-瑙尔范式(EBNF, Extended Backus–Naur Form) 是表达作为描述计算机编程语言形式语言(是用精确的数学或机器可处理的公式定义的语言) 的正规方式的上下文无关文法 的元语法(metalanguage)符号表示法。它是巴科斯范式(BNF) 元语法符号表示法的一种扩展。
简单的理解就是用来描述语言词法和语法规则的语言
ISO/IEC 14977标准 基本形式 LEFT=RIGHT 意思为LEFT可由RIGHT推导而来，LEFT为非终结符，RIGHT可以为非终结符也可以为终结符； 非终结符 简单的理解就是可以继续推导的符号 终结符 不可被推导的符号
符号 符号 含义 示例 = 定义 CharA=“a”; 代表CharA由字母a推导而来 , 连接符 a,b,c 代表abc是挨着的 ; 结束符 CharA=“a”; 代表 CharA这条语句定义结束 | 或者 digit = “0” | “1” | “2” | “3” | “4” | “5” | “6” | “7” | “8” | “9”; […] 可选，出现0次或1次 number = ["-"|"+"],digit 可匹配 1 -1 +1 … {…} 重复，出现>=0次 number = ["-"|"+"],digit,{digit} 可匹配 1 -1 +1 11 … (…) 分组 number = （"-"|"+"）,digit 符号必须添加，可匹配 -1 +1 … “…“或者’…' 终结符,单引号主要是一些特殊情况，比如双引号 “a"或者’a’ 由单或双引号引起来的部分是终结符，就是代表字母a，不可继续推导 (* … *) 注释 (*我是注释*) 注释不参与定义 ?…? 表示其中的内容具有特殊含义，对该含义的定义不在 EBNF 标准之内，有使用者来决定 space = ? US-ASCII character 32 ?; - 排除(将右边的内容从左边进行排除) string= allVistableChar - '”’ 表示在allVistableChar里排除"字符 示例 只允许赋值的简单编程语言可以用 EBNF
...</p></div><footer class=entry-footer>2022-07-05 15:31:12&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;3 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;430 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to EBNF" href=https://shifengbin.github.io/posts/compiler/ebnf/></a></article><article class=post-entry><header class=entry-header><h2>计算机网络简要概述</h2></header><div class=entry-content><p>计算机网络分层 市面上对网络分层主要是有三种分层
七层 五层 四层 应用层 应用层 应用层 表示层 会话层 传输层 传输层 传输层 网络层 网络层 网络层 数据链路层 数据链路层 网络接口层 物理层 物理层 每层的职责 物理层 提供物理介质,电压信号等功能
数据链路层 提供P2P传输 (点对点的, 比如一个路由器到另一个路由器)
网络层 提供E2E传输 (Endpoint to Endpoint,两个端点的传输,中间可能经过若干个路由器,注意区别P2P, E2E > P2P)
传输控制层 提供进程到进程的传输(端口到端口的传输)
应用层 应用自定义个协议
每一层都是通过下层对上层提供接口的形式来提供服务
常用网络设备 交换机 交换机工作在数据链路层, 通过mac地址进行转发, 全双工网络设备, 可以隔离碰撞域, 减少链路上的信号碰撞,提高链路网络利用率
路由器 路由器工作在网际层, 通过ip进行转发, 全双工网络设备, 可以隔离广播域(广播不能通过路由器)</p></div><footer class=entry-footer>2022-07-04 21:10:39&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;53 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 计算机网络简要概述" href=https://shifengbin.github.io/posts/net/summary/></a></article><article class=post-entry><header class=entry-header><h2>Semaphore(信号量)</h2></header><div class=entry-content><p>信号量 信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量
简单的说就是通过获取资源和释放资源来进行同步的一种策略
用法 用法一共有以下几步:
创建信号量 获取信号量 释放信号量 //1.创建信号量为10 sem = semaphore.NewWeighted(10) for i := 0; i &lt;100; i++ { go func() { ctx := context.TODO() //2.获取一个信号量, 信号量一共10个,获取最多获取10,超过的gorutine会挂起 if err := sem.Acquire(ctx, 1); err != nil { doSomething() } //3. 释放信号量,1个 sem.Release(1) }() } 代码解读 Weighted 结构(NewWeighted 返回的数据结构) type Weighted struct { size int64 //总大小,就是NewWeighted传入的个数 cur int64 //当前消耗的个数 mu sync.Mutex //互斥锁 waiters list.List //等待列表, 当信号量不足时等待的列表 } waiter 结构(等待列表保存的结构) type waiter struct { n int64 //需要的资源数 ready chan&lt;- struct{} // 用来通知gorutine } Acquire 方法 func (s *Weighted) Acquire(ctx context.Context, n int64) error { s.mu.Lock() //判断当前资源是否足够,如果足够则累加s.cur直接返回 if s.size-s.cur >= n && s.waiters.Len() == 0 { s.cur += n s.mu.Unlock() return nil } //如果n 大于总资源就会等待超时或取消,(如果这种情况使用的是context.TODO,或者Background, Done返回nil,就会一直等待,导致gorutine泄露) if n > s.size { s.mu.Unlock() &lt;-ctx.Done() return ctx.Err() } //这里就是判断,总资源够,但是剩余资源不够的情况, 这时就需要其他获取资源的groutine释放资源 ready := make(chan struct{}) w := waiter{n: n, ready: ready} elem := s.waiters.PushBack(w) //把当前等待的放入队列 s.mu.Unlock() //等待超时或者资源充足 select { case &lt;-ctx.Done(): //等待超时 err := ctx.Err() s.mu.Lock() select { case &lt;-ready: //如果超时后立刻有足够资源时也会返回 err = nil default: //超时后的逻辑 isFront := s.waiters.Front() == elem //判断当前等待的是队列头部元素(因为资源被释放后优先分配给队列头部的) s.waiters.Remove(elem) //移除超时的waiter if isFront && s.size > s.cur { //去掉头部后并且有剩余就看下,下个waiter能否满足 s.notifyWaiters() } } s.mu.Unlock() return err case &lt;-ready: //等待资源 return nil } } notifyWaiters 方法 func (s *Weighted) notifyWaiters() { for { //取出队列头部的waiter next := s.waiters.Front() if next == nil { //没有等待的waiter就退出循环 break } w := next.Value.(waiter) //如果资源不能满足则退出循环 if s.size-s.cur &lt; w.n { break } //如果能满足,就移除当前元素,关闭waiter.ready(Acquire 中 &lt;-w.ready 就能取消阻塞) s.cur += w.n s.waiters.Remove(next) close(w.ready) } } Release 方法 func (s *Weighted) Release(n int64) { s.mu.Lock() //从当前使用减去n s.cur -= n if s.cur &lt; 0 { //如果Release的资源超过,Acquire的资源就会发生panic s.mu.Unlock() panic("semaphore: released more than held") } //唤醒waiter s.notifyWaiters() s.mu.Unlock() }</p></div><footer class=entry-footer>2022-07-01 23:51:45&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;262 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Semaphore(信号量)" href=https://shifengbin.github.io/posts/go_source/semaphore/></a></article><article class=post-entry><header class=entry-header><h2>K3s安装</h2></header><div class=entry-content><p>安装步骤 根据官方文档使用 curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - 一条命令安装
安装过程的坑 建议使用Raspberry OS, 之前使用过Ubuntu 22.04 安装后发生节点有时Ready有时NotReady反复横跳, 最后用Raspberry OS安装成功 Raspberry也有点小坑,需要在/boot/cmdline.txt文件最后用空格,不要换行, 添加cgroup_memory=1 cgroup_enable=memory, 然后重启 `` 官方文档</p></div><footer class=entry-footer>2022-06-29 00:02:05&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;24 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to K3s安装" href=https://shifengbin.github.io/posts/pi/k3s/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://shifengbin.github.io/page/3/>«&nbsp;上一页&nbsp;
</a><a class=next href=https://shifengbin.github.io/page/5/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://shifengbin.github.io/>Blog Zone</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{let e="dark";document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),e="light"):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),e="dark");for(let t of window.themeOberver)t(e)})</script></body></html>