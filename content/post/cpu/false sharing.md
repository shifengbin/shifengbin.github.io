在解释缓存 false sharing 之前，有必要简要介绍一下缓存在 CPU 架构中的工作原理。

CPU 中缓存的最小化单位是缓存行（现在来说，CPU 中常见的缓存行大小为 64 字节）。因此，当 CPU 从内存中读取变量时，它将读取该变量附近的所有变量。图 1 是一个简单的例子：



![图1](/Users/fengbinshi/Documents/笔记/images/1.png)



当 core1 从内存中读取变量 a 时，它会同时将变量 b 读入缓存。（顺便说一下，我认为 CPU 从内存中批量读取变量的主要原因是基于空间局部性理论：当 CPU 访问一个变量时，它可能很快就会读取它旁边的变量。）（译者注：关于空间局部性理论可以参考[这篇文章](https://zhuanlan.zhihu.com/p/43104786)）

该缓存架构存在一个问题：如果一个变量存在于不同 CPU 核心中的两个缓存行中，如图 2 所示：



![图2](/Users/fengbinshi/Documents/笔记/images/2.png)



当 core1 更新变量 a 时：



![图3](/Users/fengbinshi/Documents/笔记/images/3.png)



当 core2 读取变量 b 时，即使变量 b 未被修改，它也会使 core2 的缓存未命中。所以 core2 会从内存中重新加载缓存行中的所有变量，如图 4 所示：



![图4](/Users/fengbinshi/Documents/笔记/images/4.png)



这就是缓存 false sharing：一个 CPU 核更新变量会强制其他 CPU 核更新缓存。而我们都知道从缓存中读取 CPU 的变量比从内存中读取变量要快得多。因此，虽然该变量一直存在于多核中，但这会显著影响性能。

解决该问题的常用方法是缓存填充：在变量之间填充一些无意义的变量。使一个变量单独占用 CPU 核的缓存行，因此当其他核更新时，其他变量不会使该核从内存中重新加载变量。



链接：https://juejin.cn/post/6844903866270482445