<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Blog Zone</title>
<meta name=keywords content><meta name=description content="Posts - Blog Zone"><meta name=author content="Fengbin"><link rel=canonical href=https://shifengbin.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><link rel=icon href=https://shifengbin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shifengbin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shifengbin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://shifengbin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://shifengbin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://shifengbin.github.io/posts/index.xml><link rel=alternate hreflang=zh href=https://shifengbin.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://shifengbin.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shifengbin.github.io/ accesskey=h title="Blog Zone (Alt + H)">Blog Zone</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://shifengbin.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://shifengbin.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://shifengbin.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://shifengbin.github.io/>主页</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>Flink k8s中的使用</h2></header><div class=entry-content><p>flink使用 本文讲解的是在k8s中使用flink,摆脱yarn, hdfs等大数据组件
k8s 部署(手动部署HA模式) 想要实现K8S的HA模式必须要有几个条件
要有能查看,添加,修改,删除configmap权限的账户 # flink-service-account.yaml apiVersion: v1 kind: ServiceAccount metadata: name: flink-sa namespace: flink-namespace --- apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: flink-role namespace: flink-namespace rules: - apiGroups: [""] resources: ["configmaps"] verbs: ["create", "get", "list", "watch", "update", "delete", "patch"] - apiGroups: [""] resources: ["pods"] verbs: ["get", "list", "watch"] - apiGroups: [""] resources: ["services"] verbs: ["get", "list", "watch"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: flink-role-binding namespace: flink-namespace subjects: - kind: ServiceAccount name: flink-sa namespace: flink-namespace roleRef: kind: Role name: flink-role apiGroup: rbac.authorization.k8s.io 配置文件开启高可用模式为kubernetes和配置集群id,检查点和重启策略 #高可用配置 high-availability.type: kubernetes high-availability.storageDir: file:///flink/storage/ha #集群信息 kubernetes.cluster-id: flink-cluster-001 kubernetes.namespace: flink-namespace #状态后端,检查点保存点默认位置,可以配置为oss state.backend.type: filesystem state.checkpoints.dir: file:///flink/storage/checkpoints state.savepoints.dir: file:///flink/storage/savepoints #检查点执行配置 execution.checkpointing.interval: 20s execution.checkpointing.max-concurrent-checkpoints: 1 execution.checkpointing.mode: EXACTLY_ONCE execution.checkpointing.timeout: 1min #重启策略 restart-strategy.type: fixed-delay restart-strategy.fixed-delay.attempts: 10 restart-strategy.fixed-delay.delay: 30s session模式 创建命名空间 我们把flink部署到名称为flink-namespace的命名空间中(创建命名空间kubectl create namespace flink-namespace)
...</p></div><footer class=entry-footer>2025-09-29 15:31:13&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;7 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1349 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Flink k8s中的使用" href=https://shifengbin.github.io/posts/flink/flink/></a></article><article class=post-entry><header class=entry-header><h2>简单的数据库任务队列设计</h2></header><div class=entry-content><p>当我们使用数据库来管理异步任务时,更新服务怎么保证任务中断后还能继续执行? 假设我们有个表
-- TaskStatusInit = 0 -- TaskStatusDoing = 1 -- TaskStatusDone = 2 -- TaskStatusFailed = 3 create table task ( id serial primary key, task_info jsonb, task_status smallint, created_at timestamp default CURRENT_TIMESTAMP, updated_at timestamp default CURRENT_TIMESTAMP, ); 当更新应用或者有意外情况导致task_status一直处于TaskStatusDoing,导致无法继续执行.这时我们可以这样
create table task ( id serial primary key, task_info jsonb, task_status smallint, heartbeat bigint, -- 添加一个心跳字段 created_at timestamp default CURRENT_TIMESTAMP, updated_at timestamp default CURRENT_TIMESTAMP, ); 添加一个心跳字段,在执行过程中定时去更新他,如果超过一定的时间没有更新就说明这个任务已经中断了.这时候我们就可以放心的把状态重置为我们想要的状态了.
...</p></div><footer class=entry-footer>2025-08-14 14:06:15&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;95 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 简单的数据库任务队列设计" href=https://shifengbin.github.io/posts/others/task/></a></article><article class=post-entry><header class=entry-header><h2>ESP32项目增加Menuconfig</h2></header><div class=entry-content><p>ESP32使用Kconfig管理配置,想要在menuconfig中添加配置项需要如下操作
在main目录下创建Kconfig.projbuild 在里面编辑类似内容 menu "自定义菜单名称" config YOUR_CONFIG_NAME # 会生成CONFIG_YOUR_CONFIG_NAME的配置项 bool "布尔选项描述" # 布尔类型（是/否） default y # 默认值 help # 帮助信息 "详细说明" config LED_GPIO_NUM # 示例：整数型配置 int "LED的GPIO引脚号" range 0 39 # 取值范围 default 10 # 默认值 choice # 单选选项 prompt "选择模式" default MODE_A config MODE_A #如果选择这个则会生成CONFIG_MODE_A这个配置 bool "模式A" config MODE_B #没选择的不会生成CONFIG_MODE_B bool "模式B" endchoice endmenu 在代码中引用#include "sdkconfig.h"就可以使用生成的相关配置了</p></div><footer class=entry-footer>2025-07-01 11:09:03&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;57 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to ESP32项目增加Menuconfig" href=https://shifengbin.github.io/posts/esp32/menuconfig/></a></article><article class=post-entry><header class=entry-header><h2>Spi</h2></header><div class=entry-content><p>spi使用步骤 1.配置总线 #include "driver/spi_master.h" // 1. 配置总线参数 spi_bus_config_t buscfg = { .mosi_io_num = 13, // MOSI 引脚 .miso_io_num = 12, // MISO 引脚 .sclk_io_num = 14, // SCLK 引脚 .quadwp_io_num = -1, // 未使用（保留 -1） .quadhd_io_num = -1, // 未使用（保留 -1） .max_transfer_sz = 4096 // 最大传输字节数 }; // 初始化 SPI 总线（如 SPI2_HOST） ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &amp;buscfg, SPI_DMA_CH_AUTO)); 2.添加设备到总线 spi_device_interface_config_t devcfg = { .clock_speed_hz = 10 * 1000 * 1000, // 时钟频率 (10 MHz) .mode = 0, // SPI 模式 0 .spics_io_num = 15, // 片选引脚 (CS) .queue_size = 7, // 传输队列大小 }; spi_device_handle_t spi; // 设备句柄 ESP_ERROR_CHECK(spi_bus_add_device(SPI2_HOST, &amp;devcfg, &amp;spi)); 3.传输数据 uint8_t send_buf[4] = {0x01, 0x02, 0x03, 0x04}; uint8_t recv_buf[4] = {0}; // 接收缓冲区 spi_transaction_t t = { .tx_buffer = send_buf, // 发送数据指针 .rx_buffer = recv_buf, // 接收数据指针 .length = 32, // 总位数 (4字节 * 8 = 32位) }; // 执行传输（阻塞模式） ESP_ERROR_CHECK(spi_device_transmit(spi, &amp;t)); 4.释放资源(不使用spi后) spi_bus_remove_device(spi); // 移除设备 spi_bus_free(SPI2_HOST); // 释放总线 理解SPI SPI2_HOST 是SPI控制器标识符,根据总线配置和设备配置进行收发数据和DMA启动等, SPI1_HOST一般是不使用的,这个控制器一般用来内部flash使用 不管是spi_bus_config_t总线配置,还是spi_device_interface_config_t设备配置,都是在配置SPI控制器如何收发数据,拆分开成两个配置是为了通用性,总线是一组设备公用的配置,同一个总线上可以有多个设备,而设备配置是和具体设备紧密关联的配置比如片选信由那个GPIO发送 总线配置是物理层设定(线路怎么接); 设备配置是协议层设定(信号怎么发)</p></div><footer class=entry-footer>2025-06-30 10:53:45&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;154 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Spi" href=https://shifengbin.github.io/posts/esp32/spi/></a></article><article class=post-entry><header class=entry-header><h2>无损滚动更新机制</h2></header><div class=entry-content><p>想要进行无损滚动更新需要保证一下3点
应用支持优雅退出(收到退出信号时不接收新请求并且要处理完已经接收到的请求) k8s正确配置readnessProbe就绪探针 添加生命周期函数preStop添加一定的延时, 比如preStop.exec.commend: ["/bin/sh", “-c”, “sleep 10”] 主要原因为Kubernetes 在终止 Pod 时的操作顺序是
标记 Pod 为 Terminating 状态：当 Kubernetes 接收到删除 Pod 的请求时，它会将 Pod 的状态设置为 Terminating 执行 preStop 钩子：如果 Pod 定义了 preStop 钩子，Kubernetes 会立即同步执行这个钩子 并行更新 Endpoint：在 Kubernetes 标记 Pod 为 Terminating 状态的同时，Endpoint Controller 会异步地从相关的服务端点（endpoints）中移除该 Pod 的 IP 地址。Kube-proxy 也会开始更新其网络规则，以停止向该 Pod 转发流量 发送 SIGTERM 信号：一旦 preStop 钩子完成，Kubernetes 会向 Pod 中的容器发送 SIGTERM 信号，告诉容器开始优雅地关闭 等待或强制终止：如果容器在终止宽限期(terminationGracePeriodSeconds)内没有关闭，Kubernetes 会发送 SIGKILL 信号强制终止容器。 k8s doc
%% Kubernetes Pod 终止流程（Endpoint更新与preStop并行） graph TD A[用户/系统删除Pod] --> B(标记Pod为Terminating状态) B --> C[[Endpoint控制器异步移除Pod IP]] B --> D{执行preStop钩子} C --> E[停止流量路由到Pod] D -->|同步等待完成或超时| F[发送SIGTERM信号] F --> G{进程处理SIGTERM} G -->|异步处理| H[等待退出] H --> I{是否在terminationGracePeriod内退出?} I -->|是| J[Pod终止完成] I -->|否| K[发送SIGKILL强制终止] K --> J %% 同步/异步标注 style B fill:#c9f7d4,stroke:#2d8a3e style C fill:#e3f2fd,stroke:#1e88e5 style D fill:#c9f7d4,stroke:#2d8a3e style F fill:#c9f7d4,stroke:#2d8a3e style K fill:#c9f7d4,stroke:#2d8a3e style G fill:#f8e5d4,stroke:#cc6b2c style H fill:#f8e5d4,stroke:#cc6b2c 注:
...</p></div><footer class=entry-footer>2024-09-11 15:44:16&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;166 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 无损滚动更新机制" href=https://shifengbin.github.io/posts/k8s/grace_update/></a></article><article class=post-entry><header class=entry-header><h2>Kafka使用kraft搭建集群</h2></header><div class=entry-content><p>主机准备
主机 IP 系统 kafka1 192.168.10.101 ubuntu22.04 kafka2 192.168.10.102 ubuntu22.04 kafka3 192.168.10.103 ubuntu22.04 主机环境
安装java 11 kafka_2.13-3.7.0 配置
这里部署的是broker和controller在一起的方式,也可以分别部署,具体修改kraft相关文件,配置都是相通的
kafka/config/kraft/server.properties
#集群角色 process.roles=broker,controller #每台机器的id不能一样 node.id=3 #这个是所有conntroller的地址,用于投票选举使用 controller.quorum.voters=1@192.168.10.101:9093,2@192.168.10.102:9093,3@192.168.10.103:9093 # 监听端口 listeners=PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093 # 客户端连接地址 advertised.listeners=PLAINTEXT://192.168.20.208:9092 # 日志地址, 这个修改到非/tmp目录,否则系统重启后会丢失 log.dirs=/var/log/kafka/kraft-combined-logs # ...其他配置按照实际情况修改 启动集群步骤:
KAFKA_CLUSTER_ID="$(bin/kafka-storage.sh random-uuid)" 这个操作只在一个机器上运行,执行后记录这个值,这个是集群id,整个集群需要一致
bin/kafka-storage.sh format -t $KAFKA_CLUSTER_ID -c config/kraft/server.properties 每个机器上都要执行, 这个KAFKA_CLUSTER_ID 就是是上面执行的值
bin/kafka-server-start.sh config/kraft/server.properties 启动集群
配置systemd开机启动
在/etc/systemd/system/kafka.service文件中添加内容
[Unit] Description=Apache Kafka Server [Service] Type=simple User=root Group=root ExecStart=/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/kraft/server.properties ExecStop=/usr/local/kafka/bin/kafka-server-stop.sh Restart=on-failure [Install] WantedBy=multi-user.target 执行sudo systemctl daemon-reload 重新加载 执行sudo systemctl enable kafka 开机启动 执行sudo systemctl start kafka 启动 使用sudo journalctl -u kafka.service查看日志 使用jps查看进程是否启动成功
...</p></div><footer class=entry-footer>2024-07-04 15:16:44&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;135 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Kafka使用kraft搭建集群" href=https://shifengbin.github.io/posts/mq/kafka_kraft/></a></article><article class=post-entry><header class=entry-header><h2>Debezium</h2></header><div class=entry-content><p>Debezium 用于捕获数据库中的更改，以便应用程序可以查看这些更改并对其做出响应。 Debezium 会记录每个数据库表中所有行级别的更改，并将其作为更改事件流记录下来
主流CDC工具：
canal : 监控binlog,支持mysql,社区已不活跃,非首选 debezium : 支持mysql, postgresql, mongodb等十余种数据库,mysql也支持binlog,成熟稳定 flink cdc: 主要应用于大数据,基于debezium,延迟较低 这里选择debezium的理由:
不选canal的原因 只支持mysql,并且社区已不活跃，除了老项目使用新的已经不是首选,在阿里也都边缘化了 不选flink cdc的原因,公司大数据没有flink的项目,增加运维成本，并且需要使用java开发,并不是所有开发都会使用java 选择debezium的原因，debezium成熟稳定,支持多种数据库，经典的使用方式是使用的是kafka connect部署, 我们有自己的kafka,不会增加运维成本, kafka connect是kafka自带的分布式工具，不用搭建额外的平台管理任务,使用消息队列和固定语言解耦,降低开发成本 当我们想监控数据库数据变动时我可以使用一些CDC工具,这里介绍一款配合Kafka使用的Connect插件Debezium,他支持Mysql, PostgreSQL, MongoDB等
能做什么:
1. 解耦数据修改端和使用端,减少应该通知但是没有通知的数据变更的错误,或者手动修改数据库时没有或忘记通知其他端 2. 异构数据库同步数据,比如搜索相关业务,需要数据实时同步，但是要保证数据一致 3. 缓存数据的生成和过期 4. 一些计算任务(数据统计,聚合) 这里我们以MySQL为例
环境 1. Kafka 3.7 2. MySQL 8.0 3. Debezium Mysql connect Plugin 2.6.2 Final Mysql 需要开启row格式binlog
[mysqld] bind-address = 0.0.0.0 binlog_format = ROW server_id = 1 log_bin = /var/log/mysql/mysql-bin.log 需要以下权限
GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, LOCK TABLES, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password'; 权限 作用 SELECT 查询数据,仅在执行快照时使用 RELOAD 允许连接器使用 FLUSH 语句来清除或重新加载内部缓存、刷新表或获取锁。仅在执行快照时使用 SHOW DATABASES 使连接器能够通过发出 SHOW DATABASE 语句来查看数据库名称。仅在执行快照时使用 REPLICATION SLAVE 使连接器能够连接并读取 MySQL 服务器二进制日志 REPLICATION CLIENT 允许连接器使用以下语句：SHOW MASTER STATUS,SHOW SLAVE STATUS,SHOW BINARY LOGS LOCK TABLES 执行快照时需要锁表 Debezium 把插件解压到一个目录下,我这里解压到Kafka目录下,创建一个connects目录,解压到这里,解压后我的目录像这样 --kafka |--connects |--debezium-connector-mysql 在kafka的config文件夹下配置connect-distributed.properties这个文件 修改plugin.path填写connects文件夹路径
...</p></div><footer class=entry-footer>2024-06-28 11:15:28&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;425 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Debezium" href=https://shifengbin.github.io/posts/db/debezium/></a></article><article class=post-entry><header class=entry-header><h2>Deadlock检测时机</h2></header><div class=entry-content><p>Go语言的运行时会在所有活跃的goroutine都无法继续执行时判定为死锁。这意味着，只要还有至少一个goroutine能够正常运行，Go运行时就不会触发死锁检测机制。死锁检测通常在以下情况下触发：
所有goroutine都阻塞：如果所有的goroutine都在等待某些事件（如通道操作、锁获取等），而这些事件无法由其他goroutine触发（因为没有其他goroutine在运行或者能够解除阻塞状态），Go运行时就会判定程序为死锁状态。(这里不包括io等待，因为io等待是阻塞的，但是go的运行时并不会触发死锁检测机制)
这种自动死锁检测主要是为了帮助开发者在开发阶段识别出潜在的并发问题。然而，它的能力是有限的，特别是在涉及网络I/O、系统调用或者复杂锁逻辑的情况下，Go的死锁检测可能不会触发。因此，即使Go运行时没有报告死锁，也不代表程序中不存在潜在的并发问题。
为了避免死锁，推荐的做法包括：
避免循环等待：设计系统时应确保资源的分配顺序一致，以避免循环等待的情况发生。 使用适当的同步原语：比如使用带缓冲的channel、正确使用锁（如sync.Mutex）、以及其他并发控制工具（如sync.WaitGroup、context.Context等）。 限制并发数：有时通过限制系统中并发执行的goroutine数量可以简化资源管理，减少死锁的风险。 彻底测试：并发程序应该经过详尽的测试，包括使用竞态检测工具（如Go的-race标志）来帮助识别并发错误。 这些措施可以帮助开发者构建更健壮、更可靠的并发程序。</p></div><footer class=entry-footer>2024-05-08 17:52:55&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;9 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Deadlock检测时机" href=https://shifengbin.github.io/posts/go/deadlock/></a></article><article class=post-entry><header class=entry-header><h2>在docker模拟虚拟IP实验时遇到的问题</h2></header><div class=entry-content><p>获取不到虚拟IP 使用下面的命令时不能获取到虚拟IP
docker run -it --net vipnet --ip 172.18.0.2 vipimage /bin/bash 应该添加参数可以让容器有权限操作网络配置
docker run -it --net vipnet --ip 172.18.0.2 --cap-add=NET_ADMIN vipimage /bin/bash 或者
docker run -it --net vipnet --ip 172.18.0.2 --privileged vipimage /bin/bash privileged小知识 在 Docker 中使用 --privileged 标志会给容器提供类似于宿主机 root 用户的权限。当容器以 --privileged 模式运行时，它可以绕过 Linux 内核的许多安全限制，从而获得较广泛的操作权限。这通常用于需要执行一些高级系统管理操作的场景，例如直接访问硬件设备或进行某些需要特殊权限的网络操作。
--privileged 模式的主要影响包括： 全能力（Capabilities）：
容器将获得 Linux 所有的 capabilities，与在宿主机上运行的进程几乎相同。 设备访问：
容器可以访问和操作宿主机上的所有设备（/dev 下的设备）。 安全限制：
绕过了 AppArmor 或 SELinux 的限制，容器可以执行更多的系统级操作。 文件系统：
容器可以挂载宿主机上的文件系统，甚至使用一些通常需要更高权限的挂载选项。 网络操作：
允许执行一些通常受限的网络操作，如更改网络配置或使用低号端口。 使用场景 使用 --privileged 模式通常适用于以下场景：
开发和测试：
...</p></div><footer class=entry-footer>2024-04-26 18:12:19&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;132 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 在docker模拟虚拟IP实验时遇到的问题" href=https://shifengbin.github.io/posts/linux/docker_vip/></a></article><article class=post-entry><header class=entry-header><h2>Wine</h2></header><div class=entry-content><p>wine执行中文程序乱码 wine后执行winecfg配置wine时出现乱码可以使用命令安装字体解决
sudo apt-get install fonts-wqy-zenhei fonts-wqy-microhei # 安装基础组件 winetricks corefonts cjkfonts # 自动安装中文支持 # 设置中文环境 winetricks setwinver=win10 winetricks fakechinese # 模拟中文系统 WINEPREFIX=~/.wine winetricks riched20 未响应问题 运行：winecfg
在 Applications 页面将 Windows 版本改为程序要求的版本（如 Windows 7、Windows 10）。
如果不能解决问题可以尝试下面的方法,安装依赖
sudo apt install winetricks
winetricks vcrun2015 dotnet48 corefonts</p></div><footer class=entry-footer>2024-04-22 16:42:34&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;44 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Wine" href=https://shifengbin.github.io/posts/linux/wine/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://shifengbin.github.io/posts/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://shifengbin.github.io/>Blog Zone</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{let e="dark";document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),e="light"):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),e="dark");for(let t of window.themeOberver)t(e)})</script></body></html>