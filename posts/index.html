<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Blog Zone</title>
<meta name=keywords content><meta name=description content="Posts - Blog Zone"><meta name=author content="Fengbin"><link rel=canonical href=https://shifengbin.github.io/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><link rel=icon href=https://shifengbin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shifengbin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shifengbin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://shifengbin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://shifengbin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://shifengbin.github.io/posts/index.xml><link rel=alternate hreflang=zh href=https://shifengbin.github.io/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://shifengbin.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shifengbin.github.io/ accesskey=h title="Blog Zone (Alt + H)">Blog Zone</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://shifengbin.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://shifengbin.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://shifengbin.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://shifengbin.github.io/>主页</a></div><h1>Posts
<a href=index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2>Agent ReAct模式</h2></header><div class=entry-content><p>Agent模式1 — ReAct模式
ReAct Agent - 基于 Reasoning + Acting 模式的智能代理
ReAct 模式的核心思想是让 LLM 交替进行： 1. Thought (思考): 分析当前情况，决定下一步行动 2. Action (行动): 选择并执行一个工具 3. Observation (观察): 获取工具执行结果 这个循环持续进行，直到 Agent 认为可以给出最终答案。
回答中的解析可以按照
Thought: Action: Action Input: 进行正则匹配获取 比如
def _parse_response(self, response: str) -> tuple[str, Optional[str], Optional[dict], Optional[str]]: """ 解析 LLM 响应 Returns: (thought, action, action_input, final_answer) """ thought = "" action = None action_input = None final_answer = None # 提取 Thought thought_match = re.search(r"Thought:\s*(.+?)(?=Action:|Final Answer:|$)", response, re.DOTALL) if thought_match: thought = thought_match.group(1).strip() # 检查是否有 Final Answer final_match = re.search(r"Final Answer:\s*(.+?)$", response, re.DOTALL) if final_match: final_answer = final_match.group(1).strip() return thought, None, None, final_answer # 提取 Action action_match = re.search(r"Action:\s*(\w+)", response) if action_match: action = action_match.group(1).strip() # 提取 Action Input input_match = re.search(r"Action Input:\s*(\{.+?\})", response, re.DOTALL) if input_match: try: import json action_input = json.loads(input_match.group(1)) except json.JSONDecodeError: # 尝试更宽松的解析 action_input = {"input": input_match.group(1)} else: # 尝试匹配非 JSON 格式的输入 input_match = re.search(r"Action Input:\s*(.+?)(?=Thought:|Action:|$)", response, re.DOTALL) if input_match: raw_input = input_match.group(1).strip() # 根据工具类型推断参数名 if action == "calculator": action_input = {"expression": raw_input} elif action == "web_search": action_input = {"query": raw_input} elif action == "shell": action_input = {"command": raw_input} elif action == "http_request": action_input = {"url": raw_input} elif action == "python_repl": action_input = {"code": raw_input} else: action_input = {"input": raw_input} return thought, action, action_input, final_answer 提示词模板
...</p></div><footer class=entry-footer>2026-01-26 11:12:34&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;303 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Agent ReAct模式" href=https://shifengbin.github.io/posts/ai/agent-react/></a></article><article class=post-entry><header class=entry-header><h2>Prompts</h2></header><div class=entry-content><p>告别“人工智障”：7个拿来即用的AI提示词（Prompt）万能模板 你是否觉得 AI 有时候很聪明，有时候又像个“人工智障”？其实，90% 的回答质量取决于你如何提问。
正如编程界的名言“Garbage In, Garbage Out”（垃圾输入，垃圾输出），对于 ChatGPT、Claude 或文心一言这类大模型来说，提示词（Prompt）就是你的源代码。
为了帮你节省反复调试的时间，我总结了 7 个经过实战验证的 Prompt 模板。无论你是要写文案、做策划、学知识，还是单纯想找灵感，总有一款适合你。
1. BROKE 框架：通用的“万金油” 这是最基础也最稳健的框架，适用于 80% 的日常工作场景，如策划、写报告、做方案。
适用场景： 任务明确，需要结构化输出的场景。 核心逻辑： 背景(B) + 角色(R) + 目标(O) + 关键结果(K) + 演变/改进(E)。 模板内容： **角色 (Role)：** 你是一位 [职业/身份]，擅长 [核心技能]。 **背景 (Background)：** [描述当前的情况、背景信息]。 **目标 (Objective)：** 请帮我 [具体的任务目标]。 **关键结果 (Key Results)：** 输出必须包含：[要素1]、[要素2]、[要素3]。 **风格与限制 (Style & Constraints)：** 1. [限制条件1，如：预算、字数] 2. [限制条件2，如：语气、格式] **输出格式 (Format)：** 请使用 [表格/列表/Markdown] 格式。 例子： 策划团建 “你是一位资深行政主管。背景是我们部门20人刚完成大项目，身心疲惫。目标是策划3个预算人均300元以内的北京近郊团建方案。输出必须包含主题、行程、预算。请用表格形式输出。”
2. CO-STAR 框架：精细化内容创作 当你需要 AI 模仿特定风格（如小红书、LinkedIn、公关稿）时，这个框架能精准控制语气和受众。
...</p></div><footer class=entry-footer>2025-12-26 17:40:49&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;308 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Prompts" href=https://shifengbin.github.io/posts/ai/prompts/></a></article><article class=post-entry><header class=entry-header><h2>利用Minecraft学习Python</h2></header><div class=entry-content><p>环境步骤:
新的树梅派系统已经不自带Minecraft了，想要安装最简单的方法是先安装Pi-Apps
安装后需要在Games里找到Minecraft，点击安装
安装mcpi库来控制Minecraft 执行 sudo pip3 install mcpi
开始使用python控制：
随便找一个顺手的编辑器，创建一个py文件
编写python代码，例子后面举例
执行python代码，用命令也好，用编辑其自带功能也好，都可以
例子：
import mcpi import minecraft #本地游戏创建 mc = minecraft.Minecraft.create() #远程游戏创建 #mc = minecraft.Minecraft.create("192.168.1.1", 4711) mc.postToChat("123123") #向屏幕发送文字 文档资料：
Minecraft-API
Block Type
别人的文章</p></div><footer class=entry-footer>2025-12-03 12:18:36&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;34 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 利用Minecraft学习Python" href=https://shifengbin.github.io/posts/pi/minecraft/></a></article><article class=post-entry><header class=entry-header><h2>Flink k8s中的使用</h2></header><div class=entry-content><p>flink使用 本文讲解的是在k8s中使用flink,摆脱yarn, hdfs等大数据组件
k8s 部署(手动部署HA模式) 想要实现K8S的HA模式必须要有几个条件
要有能查看,添加,修改,删除configmap权限的账户 # flink-service-account.yaml apiVersion: v1 kind: ServiceAccount metadata: name: flink-sa namespace: flink-namespace --- apiVersion: rbac.authorization.k8s.io/v1 kind: Role metadata: name: flink-role namespace: flink-namespace rules: - apiGroups: [""] resources: ["configmaps"] verbs: ["create", "get", "list", "watch", "update", "delete", "patch"] - apiGroups: [""] resources: ["pods"] verbs: ["get", "list", "watch"] - apiGroups: [""] resources: ["services"] verbs: ["get", "list", "watch"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: RoleBinding metadata: name: flink-role-binding namespace: flink-namespace subjects: - kind: ServiceAccount name: flink-sa namespace: flink-namespace roleRef: kind: Role name: flink-role apiGroup: rbac.authorization.k8s.io 配置文件开启高可用模式为kubernetes和配置集群id,检查点和重启策略 #高可用配置 high-availability.type: kubernetes high-availability.storageDir: file:///flink/storage/ha #集群信息 kubernetes.cluster-id: flink-cluster-001 kubernetes.namespace: flink-namespace #状态后端,检查点保存点默认位置,可以配置为oss state.backend.type: filesystem state.checkpoints.dir: file:///flink/storage/checkpoints state.savepoints.dir: file:///flink/storage/savepoints #检查点执行配置 execution.checkpointing.interval: 20s execution.checkpointing.max-concurrent-checkpoints: 1 execution.checkpointing.mode: EXACTLY_ONCE execution.checkpointing.timeout: 1min #重启策略 restart-strategy.type: fixed-delay restart-strategy.fixed-delay.attempts: 10 restart-strategy.fixed-delay.delay: 30s session模式 创建命名空间 我们把flink部署到名称为flink-namespace的命名空间中(创建命名空间kubectl create namespace flink-namespace)
...</p></div><footer class=entry-footer>2025-09-29 15:31:13&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;7 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1316 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Flink k8s中的使用" href=https://shifengbin.github.io/posts/flink/flink/></a></article><article class=post-entry><header class=entry-header><h2>简单的数据库任务队列设计</h2></header><div class=entry-content><p>当我们使用数据库来管理异步任务时,更新服务怎么保证任务中断后还能继续执行? 假设我们有个表
-- TaskStatusInit = 0 -- TaskStatusDoing = 1 -- TaskStatusDone = 2 -- TaskStatusFailed = 3 create table task ( id serial primary key, task_info jsonb, task_status smallint, created_at timestamp default CURRENT_TIMESTAMP, updated_at timestamp default CURRENT_TIMESTAMP, ); 当更新应用或者有意外情况导致task_status一直处于TaskStatusDoing,导致无法继续执行.这时我们可以这样
create table task ( id serial primary key, task_info jsonb, task_status smallint, heartbeat bigint, -- 添加一个心跳字段 created_at timestamp default CURRENT_TIMESTAMP, updated_at timestamp default CURRENT_TIMESTAMP, ); 添加一个心跳字段,在执行过程中定时去更新他,如果超过一定的时间没有更新就说明这个任务已经中断了.这时候我们就可以放心的把状态重置为我们想要的状态了.
...</p></div><footer class=entry-footer>2025-08-14 14:06:15&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;95 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 简单的数据库任务队列设计" href=https://shifengbin.github.io/posts/others/task/></a></article><article class=post-entry><header class=entry-header><h2>ESP32项目增加Menuconfig</h2></header><div class=entry-content><p>ESP32使用Kconfig管理配置,想要在menuconfig中添加配置项需要如下操作
在main目录下创建Kconfig.projbuild 在里面编辑类似内容 menu "自定义菜单名称" config YOUR_CONFIG_NAME # 会生成CONFIG_YOUR_CONFIG_NAME的配置项 bool "布尔选项描述" # 布尔类型（是/否） default y # 默认值 help # 帮助信息 "详细说明" config LED_GPIO_NUM # 示例：整数型配置 int "LED的GPIO引脚号" range 0 39 # 取值范围 default 10 # 默认值 choice # 单选选项 prompt "选择模式" default MODE_A config MODE_A #如果选择这个则会生成CONFIG_MODE_A这个配置 bool "模式A" config MODE_B #没选择的不会生成CONFIG_MODE_B bool "模式B" endchoice endmenu 在代码中引用#include "sdkconfig.h"就可以使用生成的相关配置了</p></div><footer class=entry-footer>2025-07-01 11:09:03&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;57 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to ESP32项目增加Menuconfig" href=https://shifengbin.github.io/posts/esp32/menuconfig/></a></article><article class=post-entry><header class=entry-header><h2>Spi</h2></header><div class=entry-content><p>spi使用步骤 1.配置总线 #include "driver/spi_master.h" // 1. 配置总线参数 spi_bus_config_t buscfg = { .mosi_io_num = 13, // MOSI 引脚 .miso_io_num = 12, // MISO 引脚 .sclk_io_num = 14, // SCLK 引脚 .quadwp_io_num = -1, // 未使用（保留 -1） .quadhd_io_num = -1, // 未使用（保留 -1） .max_transfer_sz = 4096 // 最大传输字节数 }; // 初始化 SPI 总线（如 SPI2_HOST） ESP_ERROR_CHECK(spi_bus_initialize(SPI2_HOST, &amp;buscfg, SPI_DMA_CH_AUTO)); 2.添加设备到总线 spi_device_interface_config_t devcfg = { .clock_speed_hz = 10 * 1000 * 1000, // 时钟频率 (10 MHz) .mode = 0, // SPI 模式 0 .spics_io_num = 15, // 片选引脚 (CS) .queue_size = 7, // 传输队列大小 }; spi_device_handle_t spi; // 设备句柄 ESP_ERROR_CHECK(spi_bus_add_device(SPI2_HOST, &amp;devcfg, &amp;spi)); 3.传输数据 uint8_t send_buf[4] = {0x01, 0x02, 0x03, 0x04}; uint8_t recv_buf[4] = {0}; // 接收缓冲区 spi_transaction_t t = { .tx_buffer = send_buf, // 发送数据指针 .rx_buffer = recv_buf, // 接收数据指针 .length = 32, // 总位数 (4字节 * 8 = 32位) }; // 执行传输（阻塞模式） ESP_ERROR_CHECK(spi_device_transmit(spi, &amp;t)); 4.释放资源(不使用spi后) spi_bus_remove_device(spi); // 移除设备 spi_bus_free(SPI2_HOST); // 释放总线 理解SPI SPI2_HOST 是SPI控制器标识符,根据总线配置和设备配置进行收发数据和DMA启动等, SPI1_HOST一般是不使用的,这个控制器一般用来内部flash使用 不管是spi_bus_config_t总线配置,还是spi_device_interface_config_t设备配置,都是在配置SPI控制器如何收发数据,拆分开成两个配置是为了通用性,总线是一组设备公用的配置,同一个总线上可以有多个设备,而设备配置是和具体设备紧密关联的配置比如片选信由那个GPIO发送 总线配置是物理层设定(线路怎么接); 设备配置是协议层设定(信号怎么发)</p></div><footer class=entry-footer>2025-06-30 10:53:45&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;154 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Spi" href=https://shifengbin.github.io/posts/esp32/spi/></a></article><article class=post-entry><header class=entry-header><h2>无损滚动更新机制</h2></header><div class=entry-content><p>想要进行无损滚动更新需要保证一下3点
应用支持优雅退出(收到退出信号时不接收新请求并且要处理完已经接收到的请求) k8s正确配置readnessProbe就绪探针 添加生命周期函数preStop添加一定的延时, 比如preStop.exec.commend: ["/bin/sh", “-c”, “sleep 10”] 主要原因为Kubernetes 在终止 Pod 时的操作顺序是
标记 Pod 为 Terminating 状态：当 Kubernetes 接收到删除 Pod 的请求时，它会将 Pod 的状态设置为 Terminating 执行 preStop 钩子：如果 Pod 定义了 preStop 钩子，Kubernetes 会立即同步执行这个钩子 并行更新 Endpoint：在 Kubernetes 标记 Pod 为 Terminating 状态的同时，Endpoint Controller 会异步地从相关的服务端点（endpoints）中移除该 Pod 的 IP 地址。Kube-proxy 也会开始更新其网络规则，以停止向该 Pod 转发流量 发送 SIGTERM 信号：一旦 preStop 钩子完成，Kubernetes 会向 Pod 中的容器发送 SIGTERM 信号，告诉容器开始优雅地关闭 等待或强制终止：如果容器在终止宽限期(terminationGracePeriodSeconds)内没有关闭，Kubernetes 会发送 SIGKILL 信号强制终止容器。 k8s doc
%% Kubernetes Pod 终止流程（Endpoint更新与preStop并行） graph TD A[用户/系统删除Pod] --> B(标记Pod为Terminating状态) B --> C[[Endpoint控制器异步移除Pod IP]] B --> D{执行preStop钩子} C --> E[停止流量路由到Pod] D -->|同步等待完成或超时| F[发送SIGTERM信号] F --> G{进程处理SIGTERM} G -->|异步处理| H[等待退出] H --> I{是否在terminationGracePeriod内退出?} I -->|是| J[Pod终止完成] I -->|否| K[发送SIGKILL强制终止] K --> J %% 同步/异步标注 style B fill:#c9f7d4,stroke:#2d8a3e style C fill:#e3f2fd,stroke:#1e88e5 style D fill:#c9f7d4,stroke:#2d8a3e style F fill:#c9f7d4,stroke:#2d8a3e style K fill:#c9f7d4,stroke:#2d8a3e style G fill:#f8e5d4,stroke:#cc6b2c style H fill:#f8e5d4,stroke:#cc6b2c 注:
...</p></div><footer class=entry-footer>2024-09-11 15:44:16&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;166 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to 无损滚动更新机制" href=https://shifengbin.github.io/posts/k8s/grace_update/></a></article><article class=post-entry><header class=entry-header><h2>Kafka使用kraft搭建集群</h2></header><div class=entry-content><p>主机准备
主机 IP 系统 kafka1 192.168.10.101 ubuntu22.04 kafka2 192.168.10.102 ubuntu22.04 kafka3 192.168.10.103 ubuntu22.04 主机环境
安装java 11 kafka_2.13-3.7.0 配置
这里部署的是broker和controller在一起的方式,也可以分别部署,具体修改kraft相关文件,配置都是相通的
kafka/config/kraft/server.properties
#集群角色 process.roles=broker,controller #每台机器的id不能一样 node.id=3 #这个是所有conntroller的地址,用于投票选举使用 controller.quorum.voters=1@192.168.10.101:9093,2@192.168.10.102:9093,3@192.168.10.103:9093 # 监听端口 listeners=PLAINTEXT://0.0.0.0:9092,CONTROLLER://0.0.0.0:9093 # 客户端连接地址 advertised.listeners=PLAINTEXT://192.168.20.208:9092 # 日志地址, 这个修改到非/tmp目录,否则系统重启后会丢失 log.dirs=/var/log/kafka/kraft-combined-logs # ...其他配置按照实际情况修改 启动集群步骤:
KAFKA_CLUSTER_ID="$(bin/kafka-storage.sh random-uuid)" 这个操作只在一个机器上运行,执行后记录这个值,这个是集群id,整个集群需要一致
bin/kafka-storage.sh format -t $KAFKA_CLUSTER_ID -c config/kraft/server.properties 每个机器上都要执行, 这个KAFKA_CLUSTER_ID 就是是上面执行的值
bin/kafka-server-start.sh config/kraft/server.properties 启动集群
配置systemd开机启动
在/etc/systemd/system/kafka.service文件中添加内容
[Unit] Description=Apache Kafka Server [Service] Type=simple User=root Group=root ExecStart=/usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/kraft/server.properties ExecStop=/usr/local/kafka/bin/kafka-server-stop.sh Restart=on-failure [Install] WantedBy=multi-user.target 执行sudo systemctl daemon-reload 重新加载 执行sudo systemctl enable kafka 开机启动 执行sudo systemctl start kafka 启动 使用sudo journalctl -u kafka.service查看日志 使用jps查看进程是否启动成功
...</p></div><footer class=entry-footer>2024-07-04 15:16:44&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;1 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;135 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Kafka使用kraft搭建集群" href=https://shifengbin.github.io/posts/mq/kafka_kraft/></a></article><article class=post-entry><header class=entry-header><h2>Debezium</h2></header><div class=entry-content><p>Debezium 用于捕获数据库中的更改，以便应用程序可以查看这些更改并对其做出响应。 Debezium 会记录每个数据库表中所有行级别的更改，并将其作为更改事件流记录下来
主流CDC工具：
canal : 监控binlog,支持mysql,社区已不活跃,非首选 debezium : 支持mysql, postgresql, mongodb等十余种数据库,mysql也支持binlog,成熟稳定 flink cdc: 主要应用于大数据,基于debezium,延迟较低 这里选择debezium的理由:
不选canal的原因 只支持mysql,并且社区已不活跃，除了老项目使用新的已经不是首选,在阿里也都边缘化了 不选flink cdc的原因,公司大数据没有flink的项目,增加运维成本，并且需要使用java开发,并不是所有开发都会使用java 选择debezium的原因，debezium成熟稳定,支持多种数据库，经典的使用方式是使用的是kafka connect部署, 我们有自己的kafka,不会增加运维成本, kafka connect是kafka自带的分布式工具，不用搭建额外的平台管理任务,使用消息队列和固定语言解耦,降低开发成本 当我们想监控数据库数据变动时我可以使用一些CDC工具,这里介绍一款配合Kafka使用的Connect插件Debezium,他支持Mysql, PostgreSQL, MongoDB等
能做什么:
1. 解耦数据修改端和使用端,减少应该通知但是没有通知的数据变更的错误,或者手动修改数据库时没有或忘记通知其他端 2. 异构数据库同步数据,比如搜索相关业务,需要数据实时同步，但是要保证数据一致 3. 缓存数据的生成和过期 4. 一些计算任务(数据统计,聚合) 这里我们以MySQL为例
环境 1. Kafka 3.7 2. MySQL 8.0 3. Debezium Mysql connect Plugin 2.6.2 Final Mysql 需要开启row格式binlog
[mysqld] bind-address = 0.0.0.0 binlog_format = ROW server_id = 1 log_bin = /var/log/mysql/mysql-bin.log 需要以下权限
GRANT SELECT, RELOAD, SHOW DATABASES, REPLICATION SLAVE, LOCK TABLES, REPLICATION CLIENT ON *.* TO 'user' IDENTIFIED BY 'password'; 权限 作用 SELECT 查询数据,仅在执行快照时使用 RELOAD 允许连接器使用 FLUSH 语句来清除或重新加载内部缓存、刷新表或获取锁。仅在执行快照时使用 SHOW DATABASES 使连接器能够通过发出 SHOW DATABASE 语句来查看数据库名称。仅在执行快照时使用 REPLICATION SLAVE 使连接器能够连接并读取 MySQL 服务器二进制日志 REPLICATION CLIENT 允许连接器使用以下语句：SHOW MASTER STATUS,SHOW SLAVE STATUS,SHOW BINARY LOGS LOCK TABLES 执行快照时需要锁表 Debezium 把插件解压到一个目录下,我这里解压到Kafka目录下,创建一个connects目录,解压到这里,解压后我的目录像这样 --kafka |--connects |--debezium-connector-mysql 在kafka的config文件夹下配置connect-distributed.properties这个文件 修改plugin.path填写connects文件夹路径
...</p></div><footer class=entry-footer>2024-06-28 11:15:28&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;2 分钟&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;425 字&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;Fengbin</footer><a class=entry-link aria-label="post link to Debezium" href=https://shifengbin.github.io/posts/db/debezium/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://shifengbin.github.io/posts/page/2/>下一页&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2026 <a href=https://shifengbin.github.io/>Blog Zone</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{let e="dark";document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),e="light"):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),e="dark");for(let t of window.themeOberver)t(e)})</script></body></html>