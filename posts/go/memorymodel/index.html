<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go内存模型 | Blog Zone</title>
<meta name=keywords content="Happens before,先行发生,go 内存模型"><meta name=description content='

介绍
Go内存模型指定了一种条件，在这种条件下，可以保证读取一个goroutine中的变量，以观察不同goroutine中写入同一变量所产生的值。
建议
修改多个goroutine同时访问的数据必须序列化访问
序列化访问保护数据使用channel操作或者其他同步原语比如sync或者sync/atomic包
Happens before
在一个goroutine中,读写必须表现得就像它们按照程序指定的顺序执行一样;也就是说 在一个goroutine中,处理器和编译器可以重排读写的执行顺序,仅当重排后的行为不改变语言的设定.因为重排,一个goroutine观察到的执行顺序可能与另一个goroutine观察到的顺序不同.举个例子,如果一个goroutine执行a = 1; b = 2;,另一个可能会观察到b在a之前更新.
为了指定读写的需要，我们定义了在Go程序中执行内存操作的偏序(partial order)。如果事件$e_1$先发生于事件$e_2$我们说$e_2$后发生于$e_1$. 同样的如果$e_1$没有先发生于$e_2$并且$e_1$没有后发生于$e_2$那么我们说$e_1 e_2$同时发生.
在单个gorutine里, happens-before的顺序是程序表示的顺序.
如果下面两个条件成立,则允许变量v的读r 观察到对v的写w:

r没有先发生于w
没有其他对v的写w&rsquo; ,后发生于w, 先发生于r (也就是在w 和 r之间不存在 w&#39;)

为了保证r能读到w的写,要确保w是允许r观察的唯一写入.也就是说，如果以下两个条件均成立，则保证r观察到w：

w先发生于r
任何其他写入共享变量v都要先发生于w或者后发生于r

这对条件比第一对更严格,这一对要求没有其他的写同时发生于w或r
在单个gorutine中没有并发,这两个定义是等价的:读r观察最近写入w到v的值.
在多个gorutine访问一个共享变量v,必须使用同步事件来建立happens-before条件来确保读到期望的写.
变量v的类型为零值时，变量v的初始化行为就像在内存模型中写入一样。(初始化等同于写入)
读写超过机器字(machine word)的行为就和以未指定的顺序执行多个机器字大小的操作一样(超过machine word 每个machine word 读取和写入顺序可能不是期望的)
总之, 想要在一个gorutine中读到另一个gorutine的写就要保证, 写在读之前发生,如果我们不加控制,这个写先于读的顺序就很难保证,所以我们需要使用atomic或者和lock机制来保证顺序保证happens-before
同步
初始化
程序初始化在单个goroutine中运行，但该goroutine可能会创建其他并发运行的goroutine。
如果包p导入包q，则q的init函数的完成时间在任何p的开始之前。
函数main的开始。main在所有init函数完成后发生。
Goroutine创建
启动新goroutine的go语句发生在goroutine开始执行之前。
举例
var a string

func f() {
	print(a)
}

func hello() {
	a = "hello, world"
	go f()
}
调用hello将在将来hello, world,可能hello已经返回
Goroutine销毁
goroutine的退出不能保证先发生于任何事件,例如:'><meta name=author content><link rel=canonical href=https://shifengbin.github.io/posts/go/memorymodel/><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://shifengbin.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://shifengbin.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://shifengbin.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://shifengbin.github.io/apple-touch-icon.png><link rel=mask-icon href=https://shifengbin.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://shifengbin.github.io/posts/go/memorymodel/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="go内存模型"><meta property="og:description" content='

介绍
Go内存模型指定了一种条件，在这种条件下，可以保证读取一个goroutine中的变量，以观察不同goroutine中写入同一变量所产生的值。
建议
修改多个goroutine同时访问的数据必须序列化访问
序列化访问保护数据使用channel操作或者其他同步原语比如sync或者sync/atomic包
Happens before
在一个goroutine中,读写必须表现得就像它们按照程序指定的顺序执行一样;也就是说 在一个goroutine中,处理器和编译器可以重排读写的执行顺序,仅当重排后的行为不改变语言的设定.因为重排,一个goroutine观察到的执行顺序可能与另一个goroutine观察到的顺序不同.举个例子,如果一个goroutine执行a = 1; b = 2;,另一个可能会观察到b在a之前更新.
为了指定读写的需要，我们定义了在Go程序中执行内存操作的偏序(partial order)。如果事件$e_1$先发生于事件$e_2$我们说$e_2$后发生于$e_1$. 同样的如果$e_1$没有先发生于$e_2$并且$e_1$没有后发生于$e_2$那么我们说$e_1 e_2$同时发生.
在单个gorutine里, happens-before的顺序是程序表示的顺序.
如果下面两个条件成立,则允许变量v的读r 观察到对v的写w:

r没有先发生于w
没有其他对v的写w&rsquo; ,后发生于w, 先发生于r (也就是在w 和 r之间不存在 w&#39;)

为了保证r能读到w的写,要确保w是允许r观察的唯一写入.也就是说，如果以下两个条件均成立，则保证r观察到w：

w先发生于r
任何其他写入共享变量v都要先发生于w或者后发生于r

这对条件比第一对更严格,这一对要求没有其他的写同时发生于w或r
在单个gorutine中没有并发,这两个定义是等价的:读r观察最近写入w到v的值.
在多个gorutine访问一个共享变量v,必须使用同步事件来建立happens-before条件来确保读到期望的写.
变量v的类型为零值时，变量v的初始化行为就像在内存模型中写入一样。(初始化等同于写入)
读写超过机器字(machine word)的行为就和以未指定的顺序执行多个机器字大小的操作一样(超过machine word 每个machine word 读取和写入顺序可能不是期望的)
总之, 想要在一个gorutine中读到另一个gorutine的写就要保证, 写在读之前发生,如果我们不加控制,这个写先于读的顺序就很难保证,所以我们需要使用atomic或者和lock机制来保证顺序保证happens-before
同步
初始化
程序初始化在单个goroutine中运行，但该goroutine可能会创建其他并发运行的goroutine。
如果包p导入包q，则q的init函数的完成时间在任何p的开始之前。
函数main的开始。main在所有init函数完成后发生。
Goroutine创建
启动新goroutine的go语句发生在goroutine开始执行之前。
举例
var a string

func f() {
	print(a)
}

func hello() {
	a = "hello, world"
	go f()
}
调用hello将在将来hello, world,可能hello已经返回
Goroutine销毁
goroutine的退出不能保证先发生于任何事件,例如:'><meta property="og:type" content="article"><meta property="og:url" content="https://shifengbin.github.io/posts/go/memorymodel/"><meta property="og:image" content="https://shifengbin.github.io/images/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-23T10:33:29+08:00"><meta property="article:modified_time" content="2022-06-23T10:33:29+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://shifengbin.github.io/images/cover.jpg"><meta name=twitter:title content="go内存模型"><meta name=twitter:description content='

介绍
Go内存模型指定了一种条件，在这种条件下，可以保证读取一个goroutine中的变量，以观察不同goroutine中写入同一变量所产生的值。
建议
修改多个goroutine同时访问的数据必须序列化访问
序列化访问保护数据使用channel操作或者其他同步原语比如sync或者sync/atomic包
Happens before
在一个goroutine中,读写必须表现得就像它们按照程序指定的顺序执行一样;也就是说 在一个goroutine中,处理器和编译器可以重排读写的执行顺序,仅当重排后的行为不改变语言的设定.因为重排,一个goroutine观察到的执行顺序可能与另一个goroutine观察到的顺序不同.举个例子,如果一个goroutine执行a = 1; b = 2;,另一个可能会观察到b在a之前更新.
为了指定读写的需要，我们定义了在Go程序中执行内存操作的偏序(partial order)。如果事件$e_1$先发生于事件$e_2$我们说$e_2$后发生于$e_1$. 同样的如果$e_1$没有先发生于$e_2$并且$e_1$没有后发生于$e_2$那么我们说$e_1 e_2$同时发生.
在单个gorutine里, happens-before的顺序是程序表示的顺序.
如果下面两个条件成立,则允许变量v的读r 观察到对v的写w:

r没有先发生于w
没有其他对v的写w&rsquo; ,后发生于w, 先发生于r (也就是在w 和 r之间不存在 w&#39;)

为了保证r能读到w的写,要确保w是允许r观察的唯一写入.也就是说，如果以下两个条件均成立，则保证r观察到w：

w先发生于r
任何其他写入共享变量v都要先发生于w或者后发生于r

这对条件比第一对更严格,这一对要求没有其他的写同时发生于w或r
在单个gorutine中没有并发,这两个定义是等价的:读r观察最近写入w到v的值.
在多个gorutine访问一个共享变量v,必须使用同步事件来建立happens-before条件来确保读到期望的写.
变量v的类型为零值时，变量v的初始化行为就像在内存模型中写入一样。(初始化等同于写入)
读写超过机器字(machine word)的行为就和以未指定的顺序执行多个机器字大小的操作一样(超过machine word 每个machine word 读取和写入顺序可能不是期望的)
总之, 想要在一个gorutine中读到另一个gorutine的写就要保证, 写在读之前发生,如果我们不加控制,这个写先于读的顺序就很难保证,所以我们需要使用atomic或者和lock机制来保证顺序保证happens-before
同步
初始化
程序初始化在单个goroutine中运行，但该goroutine可能会创建其他并发运行的goroutine。
如果包p导入包q，则q的init函数的完成时间在任何p的开始之前。
函数main的开始。main在所有init函数完成后发生。
Goroutine创建
启动新goroutine的go语句发生在goroutine开始执行之前。
举例
var a string

func f() {
	print(a)
}

func hello() {
	a = "hello, world"
	go f()
}
调用hello将在将来hello, world,可能hello已经返回
Goroutine销毁
goroutine的退出不能保证先发生于任何事件,例如:'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://shifengbin.github.io/posts/"},{"@type":"ListItem","position":2,"name":"go内存模型","item":"https://shifengbin.github.io/posts/go/memorymodel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"go内存模型","name":"go内存模型","description":" 介绍 Go内存模型指定了一种条件，在这种条件下，可以保证读取一个goroutine中的变量，以观察不同goroutine中写入同一变量所产生的值。\n建议 修改多个goroutine同时访问的数据必须序列化访问\n序列化访问保护数据使用channel操作或者其他同步原语比如sync或者sync/atomic包\nHappens before 在一个goroutine中,读写必须表现得就像它们按照程序指定的顺序执行一样;也就是说 在一个goroutine中,处理器和编译器可以重排读写的执行顺序,仅当重排后的行为不改变语言的设定.因为重排,一个goroutine观察到的执行顺序可能与另一个goroutine观察到的顺序不同.举个例子,如果一个goroutine执行a = 1; b = 2;,另一个可能会观察到b在a之前更新.\n为了指定读写的需要，我们定义了在Go程序中执行内存操作的偏序(partial order)。如果事件$e_1$先发生于事件$e_2$我们说$e_2$后发生于$e_1$. 同样的如果$e_1$没有先发生于$e_2$并且$e_1$没有后发生于$e_2$那么我们说$e_1 e_2$同时发生.\n在单个gorutine里, happens-before的顺序是程序表示的顺序.\n如果下面两个条件成立,则允许变量v的读r 观察到对v的写w:\nr没有先发生于w 没有其他对v的写w\u0026rsquo; ,后发生于w, 先发生于r (也就是在w 和 r之间不存在 w') 为了保证r能读到w的写,要确保w是允许r观察的唯一写入.也就是说，如果以下两个条件均成立，则保证r观察到w：\nw先发生于r 任何其他写入共享变量v都要先发生于w或者后发生于r 这对条件比第一对更严格,这一对要求没有其他的写同时发生于w或r\n在单个gorutine中没有并发,这两个定义是等价的:读r观察最近写入w到v的值.\n在多个gorutine访问一个共享变量v,必须使用同步事件来建立happens-before条件来确保读到期望的写.\n变量v的类型为零值时，变量v的初始化行为就像在内存模型中写入一样。(初始化等同于写入)\n读写超过机器字(machine word)的行为就和以未指定的顺序执行多个机器字大小的操作一样(超过machine word 每个machine word 读取和写入顺序可能不是期望的)\n总之, 想要在一个gorutine中读到另一个gorutine的写就要保证, 写在读之前发生,如果我们不加控制,这个写先于读的顺序就很难保证,所以我们需要使用atomic或者和lock机制来保证顺序保证happens-before\n同步 初始化 程序初始化在单个goroutine中运行，但该goroutine可能会创建其他并发运行的goroutine。\n如果包p导入包q，则q的init函数的完成时间在任何p的开始之前。\n函数main的开始。main在所有init函数完成后发生。\nGoroutine创建 启动新goroutine的go语句发生在goroutine开始执行之前。 举例\nvar a string func f() { print(a) } func hello() { a = \u0026#34;hello, world\u0026#34; go f() } 调用hello将在将来hello, world,可能hello已经返回\nGoroutine销毁 goroutine的退出不能保证先发生于任何事件,例如:\n","keywords":["Happens before","先行发生","go 内存模型"],"articleBody":" 介绍 Go内存模型指定了一种条件，在这种条件下，可以保证读取一个goroutine中的变量，以观察不同goroutine中写入同一变量所产生的值。\n建议 修改多个goroutine同时访问的数据必须序列化访问\n序列化访问保护数据使用channel操作或者其他同步原语比如sync或者sync/atomic包\nHappens before 在一个goroutine中,读写必须表现得就像它们按照程序指定的顺序执行一样;也就是说 在一个goroutine中,处理器和编译器可以重排读写的执行顺序,仅当重排后的行为不改变语言的设定.因为重排,一个goroutine观察到的执行顺序可能与另一个goroutine观察到的顺序不同.举个例子,如果一个goroutine执行a = 1; b = 2;,另一个可能会观察到b在a之前更新.\n为了指定读写的需要，我们定义了在Go程序中执行内存操作的偏序(partial order)。如果事件$e_1$先发生于事件$e_2$我们说$e_2$后发生于$e_1$. 同样的如果$e_1$没有先发生于$e_2$并且$e_1$没有后发生于$e_2$那么我们说$e_1 e_2$同时发生.\n在单个gorutine里, happens-before的顺序是程序表示的顺序.\n如果下面两个条件成立,则允许变量v的读r 观察到对v的写w:\nr没有先发生于w 没有其他对v的写w’ ,后发生于w, 先发生于r (也就是在w 和 r之间不存在 w') 为了保证r能读到w的写,要确保w是允许r观察的唯一写入.也就是说，如果以下两个条件均成立，则保证r观察到w：\nw先发生于r 任何其他写入共享变量v都要先发生于w或者后发生于r 这对条件比第一对更严格,这一对要求没有其他的写同时发生于w或r\n在单个gorutine中没有并发,这两个定义是等价的:读r观察最近写入w到v的值.\n在多个gorutine访问一个共享变量v,必须使用同步事件来建立happens-before条件来确保读到期望的写.\n变量v的类型为零值时，变量v的初始化行为就像在内存模型中写入一样。(初始化等同于写入)\n读写超过机器字(machine word)的行为就和以未指定的顺序执行多个机器字大小的操作一样(超过machine word 每个machine word 读取和写入顺序可能不是期望的)\n总之, 想要在一个gorutine中读到另一个gorutine的写就要保证, 写在读之前发生,如果我们不加控制,这个写先于读的顺序就很难保证,所以我们需要使用atomic或者和lock机制来保证顺序保证happens-before\n同步 初始化 程序初始化在单个goroutine中运行，但该goroutine可能会创建其他并发运行的goroutine。\n如果包p导入包q，则q的init函数的完成时间在任何p的开始之前。\n函数main的开始。main在所有init函数完成后发生。\nGoroutine创建 启动新goroutine的go语句发生在goroutine开始执行之前。 举例\nvar a string func f() { print(a) } func hello() { a = \"hello, world\" go f() } 调用hello将在将来hello, world,可能hello已经返回\nGoroutine销毁 goroutine的退出不能保证先发生于任何事件,例如:\nvar a string func hello() { go func() { a = \"hello\" }() print(a) } 赋值a没有跟着任何同步事件,所以不能保证能被其他gorutine观测到.实际上比较激进的编译器会把整个go语句删除\n如果一个gorutine的影响必须被其他gorutine观测到,使用同步机制(比如lock,channel)来建立相对的顺序\nChannel 交流 Channel交流是goroutines间同步的主要方法.特定channel上的每个发送与该channel的相应接收相匹配，通常在不同的goroutine中。\nchannel上的发送 先发生于 该通道的相应接收。 var c = make(chan int, 10) var a string func f() { a = \"hello, world\" c \u003c- 0 } func main() { go f() \u003c-c print(a) } 这个程序确保打印出hello, world, a的赋值先发生于 c的发送, 先发生于对应c接收完成, 先发生于print\nchannel关闭先发生于接收,将接收到零值,因为管道被关闭了\n在前面的例子,使用close(c)替换c\u003c-0 将有相同的行为\n接收无缓冲 先发生于 发送完成 和上面例子比较,使用了无缓冲channel, 交换了发送和接收的位置\nvar c = make(chan int) var a string func f() { a = \"hello, world\" \u003c-c } func main() { go f() c \u003c- 0 print(a) } 这个程序也能保证打印出hello, world, 赋值a 先发生于 接收c, 先发生于发送c完成,先发生于print 如果是有缓冲的channel就不能保证打印hello, world(可能打印空字符串,崩溃,或者其他),因为a 先发生于接收c, 但不能保证先发生于发送c完成\n容量为C的通道上的第k次接收 先发生于 第k+C次发送 这个规则可以用具体例子来理解,比如 k=1 C=3, 那么第1次接收 先发生于第4次发送,因为容量是3, 第1次的不接受,那么第4次的就放不进来,阻塞住\n此规则将之前的规则推广到缓冲通道。channel中的item数对应于active的数量，容量对应于同时使用的最大数量，发送item获取信号量，接收item释放信号量。这是限制并发的常见习惯用法。\n例子:此程序为work列表中的每个item启动一个goroutine，但goroutine使用限制通道进行协调，以确保一次最多有3个运行。\nvar limit = make(chan int, 3) func main() { for _, w := range work { go func(w func()) { limit \u003c- 1 w() \u003c-limit }(w) } select{} } Locks(锁) sync包中实现了两种锁数据类型sync.Mutex和sync.RWMutex 对任意sync.Mutex或者 sync.RWMutex 变量 l 并且 n \u003c m , 调用第n次l.Unlock() 先发生于 第m次 l.Lock()\n具体例子来理解 n=1 m=2 第一次l.Unlock() 先发生于 第二次l.Lock()\n例子:\nvar l sync.Mutex var a string func f() { a = \"hello, world\" l.Unlock() } func main() { l.Lock() go f() l.Lock() print(a) } 这个程序能确保输出\"hello, world\",第一次调用l.Unlock()(在f里)先发生于 第二次l.Lock()(在main里), 先发生于print\n对任意调用l.RLock(l 是sync.RWMutex类型), 存在n在调用l.RLock后发生于l.Unlock ,与之匹配的l.RUnlock 先发生于n+1的l.RLock\n意思就是说读写是互斥的,在写锁解锁后, 读锁才加, 读锁解锁后,下一个写锁才能加\nOnce sync包通过使用Once类型，在存在多个goroutine的情况下提供了一种安全的初始化机制\n多个线程可以执行once.Do(f) 对于特定的f,只有一个运行f, 其他的都将阻塞,等待f执行完\nonce.Do(f)中调用的f() 先发生于 任何调用once.Do(f)函数返回\nvar a string var once sync.Once func setup() { a = \"hello, world\" } func doprint() { once.Do(setup) print(a) } func twoprint() { go doprint() go doprint() } 调用twoprint将只调用setup一次, setup将在调用任何一个print之前完成, 结果将打印hello, world两次.\n总结 从单个gorutine的视角来看,程序的行为是顺序执行的, 从多个gorutine来看读写的顺序可能合另一个gorutine不一样,这时候我们需要用同步原语,串行化,让程序形成我们需要的顺序\n","wordCount":"319","inLanguage":"zh","datePublished":"2022-06-23T10:33:29+08:00","dateModified":"2022-06-23T10:33:29+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://shifengbin.github.io/posts/go/memorymodel/"},"publisher":{"@type":"Organization","name":"Blog Zone","logo":{"@type":"ImageObject","url":"https://shifengbin.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://shifengbin.github.io/ accesskey=h title="Blog Zone (Alt + H)">Blog Zone</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://shifengbin.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://shifengbin.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://shifengbin.github.io/contact/ title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://shifengbin.github.io/>主页</a>&nbsp;»&nbsp;<a href=https://shifengbin.github.io/posts/>Posts</a></div><h1 class=post-title>go内存模型</h1><div class=post-meta>&lt;span title='2022-06-23 10:33:29 +0800 +0800'>六月 23, 2022&lt;/span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%8b%e7%bb%8d aria-label=介绍>介绍</a></li><li><a href=#%e5%bb%ba%e8%ae%ae aria-label=建议>建议</a></li><li><a href=#happens-before aria-label="Happens before">Happens before</a></li><li><a href=#%e5%90%8c%e6%ad%a5 aria-label=同步>同步</a><ul><li><a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=初始化>初始化</a></li><li><a href=#goroutine%e5%88%9b%e5%bb%ba aria-label=Goroutine创建>Goroutine创建</a></li><li><a href=#goroutine%e9%94%80%e6%af%81 aria-label=Goroutine销毁>Goroutine销毁</a></li><li><a href=#channel-%e4%ba%a4%e6%b5%81 aria-label="Channel 交流">Channel 交流</a><ul><li><a href=#channel%e4%b8%8a%e7%9a%84%e5%8f%91%e9%80%81-%e5%85%88%e5%8f%91%e7%94%9f%e4%ba%8e-%e8%af%a5%e9%80%9a%e9%81%93%e7%9a%84%e7%9b%b8%e5%ba%94%e6%8e%a5%e6%94%b6 aria-label="channel上的发送 先发生于 该通道的相应接收。">channel上的发送 先发生于 该通道的相应接收。</a></li><li><a href=#%e6%8e%a5%e6%94%b6%e6%97%a0%e7%bc%93%e5%86%b2-%e5%85%88%e5%8f%91%e7%94%9f%e4%ba%8e-%e5%8f%91%e9%80%81%e5%ae%8c%e6%88%90 aria-label="接收无缓冲 先发生于 发送完成">接收无缓冲 先发生于 发送完成</a></li><li><a href=#%e5%ae%b9%e9%87%8f%e4%b8%bac%e7%9a%84%e9%80%9a%e9%81%93%e4%b8%8a%e7%9a%84%e7%ac%ack%e6%ac%a1%e6%8e%a5%e6%94%b6-%e5%85%88%e5%8f%91%e7%94%9f%e4%ba%8e-%e7%ac%ackc%e6%ac%a1%e5%8f%91%e9%80%81 aria-label="容量为C的通道上的第k次接收 先发生于 第k+C次发送">容量为C的通道上的第k次接收 先发生于 第k+C次发送</a></li></ul></li><li><a href=#locks%e9%94%81 aria-label=Locks(锁)>Locks(锁)</a></li><li><a href=#once aria-label=Once>Once</a></li></ul></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=/images/train.jpg alt=head></p><h1 id=介绍>介绍<a hidden class=anchor aria-hidden=true href=#介绍>#</a></h1><p>Go内存模型指定了一种条件，在这种条件下，可以保证读取一个goroutine中的变量，以观察不同goroutine中写入同一变量所产生的值。</p><h1 id=建议>建议<a hidden class=anchor aria-hidden=true href=#建议>#</a></h1><p><strong>修改</strong>多个goroutine同时访问的数据必须序列化访问</p><p>序列化访问保护数据使用<code>channel</code>操作或者其他同步原语比如<code>sync</code>或者<code>sync/atomic</code>包</p><h1 id=happens-before>Happens before<a hidden class=anchor aria-hidden=true href=#happens-before>#</a></h1><p>在一个goroutine中,读写必须表现得就像它们按照程序指定的顺序执行一样;也就是说 在一个goroutine中,处理器和编译器可以重排读写的执行顺序,仅当重排后的行为不改变语言的设定.因为重排,一个goroutine观察到的执行顺序可能与另一个goroutine观察到的顺序不同.举个例子,如果一个goroutine执行<code>a = 1; b = 2;</code>,另一个可能会观察到b在a之前更新.</p><p>为了指定读写的需要，我们定义了在Go程序中执行内存操作的偏序(partial order)。如果事件$e_1$先发生于事件$e_2$我们说$e_2$后发生于$e_1$. 同样的如果$e_1$没有先发生于$e_2$并且$e_1$没有后发生于$e_2$那么我们说$e_1 e_2$同时发生.</p><p>在单个gorutine里, <code>happens-before</code>的顺序是程序表示的顺序.</p><p>如果下面两个条件成立,则允许变量v的读r 观察到对v的写w:</p><ol><li>r没有先发生于w</li><li>没有其他对v的写w&rsquo; ,后发生于w, 先发生于r (也就是在w 和 r之间不存在 w')</li></ol><p>为了保证r能读到w的写,要确保w是允许r观察的唯一写入.也就是说，如果以下两个条件均成立，则保证r观察到w：</p><ol><li>w先发生于r</li><li>任何其他写入共享变量v都要先发生于w或者后发生于r</li></ol><p>这对条件比第一对更严格,这一对要求没有其他的写同时发生于w或r</p><p>在单个gorutine中没有并发,这两个定义是等价的:读r观察最近写入w到v的值.</p><p>在多个gorutine访问一个共享变量v,必须使用同步事件来建立<code>happens-before</code>条件来确保读到期望的写.</p><p>变量v的类型为零值时，变量v的初始化行为就像在内存模型中写入一样。(初始化等同于写入)</p><p>读写超过机器字(machine word)的行为就和以未指定的顺序执行多个机器字大小的操作一样(超过machine word 每个machine word 读取和写入顺序可能不是期望的)</p><p>总之, 想要在一个gorutine中读到另一个gorutine的写就要保证, 写在读之前发生,如果我们不加控制,这个写先于读的顺序就很难保证,所以我们需要使用atomic或者和lock机制来保证顺序保证<code>happens-before</code></p><h1 id=同步>同步<a hidden class=anchor aria-hidden=true href=#同步>#</a></h1><h2 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h2><p>程序初始化在单个goroutine中运行，但该goroutine可能会创建其他并发运行的goroutine。</p><p>如果包p导入包q，则q的init函数的完成时间在任何p的开始之前。</p><p>函数main的开始。main在所有init函数完成后发生。</p><h2 id=goroutine创建>Goroutine创建<a hidden class=anchor aria-hidden=true href=#goroutine创建>#</a></h2><p>启动新goroutine的<code>go</code>语句发生在goroutine开始执行之前。
举例</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用hello将在将来hello, world,可能hello已经返回</p><h2 id=goroutine销毁>Goroutine销毁<a hidden class=anchor aria-hidden=true href=#goroutine销毁>#</a></h2><p>goroutine的退出不能保证先发生于任何事件,例如:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>hello</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span> <span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello&#34;</span> <span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>赋值a没有跟着任何同步事件,所以不能保证能被其他gorutine观测到.实际上比较激进的编译器会把整个go语句删除</p><p>如果一个gorutine的影响必须被其他gorutine观测到,使用同步机制(比如lock,channel)来建立相对的顺序</p><h2 id=channel-交流>Channel 交流<a hidden class=anchor aria-hidden=true href=#channel-交流>#</a></h2><p>Channel交流是goroutines间同步的主要方法.特定channel上的每个发送与该channel的相应接收相匹配，通常在不同的goroutine中。</p><h3 id=channel上的发送-先发生于-该通道的相应接收>channel上的发送 先发生于 该通道的相应接收。<a hidden class=anchor aria-hidden=true href=#channel上的发送-先发生于-该通道的相应接收>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>c</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>&lt;-</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个程序确保打印出<code>hello, world</code>, a的赋值先发生于 c的发送, 先发生于对应c接收完成, 先发生于print</p><p>channel关闭先发生于接收,将接收到零值,因为管道被关闭了</p><p>在前面的例子,使用<code>close(c)</code>替换<code>c&lt;-0</code> 将有相同的行为</p><h3 id=接收无缓冲-先发生于-发送完成>接收无缓冲 先发生于 发送完成<a hidden class=anchor aria-hidden=true href=#接收无缓冲-先发生于-发送完成>#</a></h3><p>和上面例子比较,使用了无缓冲channel, 交换了发送和接收的位置</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>c</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>	<span class=o>&lt;-</span><span class=nx>c</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span> <span class=o>&lt;-</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个程序也能保证打印出<code>hello, world</code>, 赋值a 先发生于 接收c, 先发生于发送c完成,先发生于<code>print</code>
如果是有缓冲的channel就不能保证打印<code>hello, world</code>(可能打印空字符串,崩溃,或者其他),因为a 先发生于接收c, 但不能保证先发生于发送c完成</p><h3 id=容量为c的通道上的第k次接收-先发生于-第kc次发送>容量为C的通道上的第k次接收 先发生于 第k+C次发送<a hidden class=anchor aria-hidden=true href=#容量为c的通道上的第k次接收-先发生于-第kc次发送>#</a></h3><p>这个规则可以用具体例子来理解,比如 k=1 C=3, 那么第1次接收 先发生于第4次发送,因为容量是3, 第1次的不接受,那么第4次的就放不进来,阻塞住</p><p>此规则将之前的规则推广到缓冲通道。channel中的item数对应于active的数量，容量对应于同时使用的最大数量，发送item获取信号量，接收item释放信号量。这是限制并发的常见习惯用法。</p><p>例子:此程序为work列表中的每个item启动一个goroutine，但goroutine使用限制通道进行协调，以确保一次最多有3个运行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>limit</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>w</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>work</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>w</span> <span class=kd>func</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>limit</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>			<span class=nf>w</span><span class=p>()</span>
</span></span><span class=line><span class=cl>			<span class=o>&lt;-</span><span class=nx>limit</span>
</span></span><span class=line><span class=cl>		<span class=p>}(</span><span class=nx>w</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>select</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=locks锁>Locks(锁)<a hidden class=anchor aria-hidden=true href=#locks锁>#</a></h2><p><code>sync</code>包中实现了两种锁数据类型<code>sync.Mutex</code>和<code>sync.RWMutex</code>
对任意<code>sync.Mutex</code>或者 <code>sync.RWMutex</code> 变量 l 并且 n &lt; m , 调用第n次<code>l.Unlock()</code> 先发生于 第m次 <code>l.Lock()</code></p><p>具体例子来理解 n=1 m=2 第一次<code>l.Unlock()</code> 先发生于 第二次<code>l.Lock()</code></p><p>例子:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>l</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>f</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>l</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这个程序能确保输出"hello, world",第一次调用<code>l.Unlock()</code>(在f里)先发生于 第二次<code>l.Lock()</code>(在main里), 先发生于print</p><p>对任意调用<code>l.RLock</code>(l 是sync.RWMutex类型), 存在n在调用<code>l.RLock</code>后发生于<code>l.Unlock</code> ,与之匹配的<code>l.RUnlock</code> 先发生于n+1的<code>l.RLock</code></p><p>意思就是说读写是互斥的,在写锁解锁后, 读锁才加, 读锁解锁后,下一个写锁才能加</p><h2 id=once>Once<a hidden class=anchor aria-hidden=true href=#once>#</a></h2><p>sync包通过使用Once类型，在存在多个goroutine的情况下提供了一种安全的初始化机制</p><p>多个线程可以执行<code>once.Do(f)</code> 对于特定的f,只有一个运行f, 其他的都将阻塞,等待f执行完</p><p>once.Do(f)中调用的f() 先发生于 任何调用once.Do(f)函数返回</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>once</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Once</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>setup</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=p>=</span> <span class=s>&#34;hello, world&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>doprint</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>once</span><span class=p>.</span><span class=nf>Do</span><span class=p>(</span><span class=nx>setup</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nb>print</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>twoprint</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>doprint</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=nf>doprint</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>调用twoprint将只调用setup一次, setup将在调用任何一个print之前完成, 结果将打印<code>hello, world</code>两次.</p><h1 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h1><p>从单个gorutine的视角来看,程序的行为是顺序执行的, 从多个gorutine来看读写的顺序可能合另一个gorutine不一样,这时候我们需要用同步原语,串行化,让程序形成我们需要的顺序</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://shifengbin.github.io/tags/happens-before/>Happens Before</a></li><li><a href=https://shifengbin.github.io/tags/%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F/>先行发生</a></li><li><a href=https://shifengbin.github.io/tags/go-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/>Go 内存模型</a></li></ul><nav class=paginav><a class=prev href=https://shifengbin.github.io/posts/go/datarace/><span class=title>« 上一页</span><br><span>数据竞赛(Data Race)</span>
</a><a class=next href=https://shifengbin.github.io/posts/cpu/falsesharing/><span class=title>下一页 »</span><br><span>false sharing</span></a></nav></footer><div id=__comments_box></div><script>let commentID="__comments_box";function getThemeName(e){let t=e=="dark"?"photon-dark":"github-light";return t}function resetComment(e){let t=document.querySelector("#__comments_box iframe");console.log(e,getThemeName(e)),t.contentWindow.postMessage({type:"set-theme",theme:getThemeName(e)},"https://utteranc.es")}function addComment(){let t=document.body.className.includes("dark")?"photon-dark":"github-light";var n=document.getElementById(commentID),e=document.createElement("script");e.src="https://utteranc.es/client.js",e.setAttribute("repo","shifengbin/shifengbin.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),n.appendChild(e)}function initThemeObserver(){window.themeOberver==void 0&&(window.themeOberver=[]),themeOberver.push(resetComment)}initThemeObserver(),addComment()</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://shifengbin.github.io/>Blog Zone</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{let e="dark";document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light"),e="light"):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"),e="dark");for(let t of window.themeOberver)t(e)})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></body></html>